<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split Flap</title>
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="plugins/arrivals/custom.css">
</head>
<body>
    <!-- CURRENT TIME -->
    <div id="current-time" style="position: absolute; top: 25px; left: 25px; font-size: 30px; font-weight: bold;"></div>

    <!-- CONTAINER -->
    <div id="board" class="chartContainer splitflap">
        <div style="text-align:center; position:relative;">
            <input id="station-search" type="text" placeholder="Search stations (name or id)" style="margin-bottom:8px; padding:6px; width:60%; max-width:600px; background:#111; color:#fff; border:1px solid #444;" autocomplete="off" />
            <div id="station-results" style="position:absolute; left:50%; transform:translateX(-50%); top:42px; background:#0b0b0b; border:1px solid #333; max-height:220px; overflow:auto; width:60%; max-width:600px; z-index:1000; display:none;">
            </div>
            <h1 id="station-title" style="text-decoration: overline; margin:0">Loading...</h1>
        </div>

        <!-- Header: 30px/char, 15px/separator, 120px/logo -->
        <div class="header" style="width:120px;margin-left:0px;">Route</div>
        <div class="header" style="width:360px;margin-left:30px;text-align:left;">Destination</div>
        <div class="header" style="width:320px;margin-left:301px;">ETA (min)</div>
        <div class="header" style="width:270px;margin-left:80px;text-align:left;">Status</div>

        <!-- rows will be placed here dynamically from #row_template -->
    </div>
    <!-- END CONTAINER -->

    <!-- ROW TEMPLATE -->
    <script type="text/template" id="row_template">
        <div class="row">
            <div class="group line"> <!-- train line -->
                <div class="image"><span></span></div>
            </div>

            <div class="group terminal"> <!-- city -->
                <!-- Repeat full divs as needed -->
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
            </div>

            <div class="group scheduled"> <!-- scheduled -->
              <div class="number"><span></span></div>
              <div class="number"><span></span></div>
              <div class="number"><span></span></div>
            </div>

            <div class="group remarks"> <!-- remarks -->
                <!-- Repeat full divs as needed -->
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
                <div class="full"><span></span></div>
            </div>

            <div class="group status"> <!-- lights -->
                <div class="sA"></div>
                <div class="sB"></div>
            </div>
        </div>
    </script>
    <!-- END ROW TEMPLATE -->

    <!-- JS LIBRARIES -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.3.3/backbone-min.js"></script>
    <script type="text/javascript" src="js/split-flap.js"></script>
    <script type="text/javascript" src="plugins/arrivals/custom.js"></script>

    <!-- CUSTOMIZATION OPTIONS AND SCRIPT INITIALIZATION -->
    <script type="text/javascript">
        sf.options = {
            plugin: 'arrivals', // Plugin to load
            container: $('#board'), // Where in the DOM to put the board
            template: $('#row_template'), // Where in the DOM to find the row template
            numRows: 45, // number of rows to generate
            sort: 'scheduled', // the column to sort by. Use 'scheduled' to sort by arrival time, 'line' to sort by train line, or 'terminal' to sort by destination.
            order: 'asc', // the order to sort by
            maxResults: 45, // number of results to retrieve from data feed
            pageInterval: 20000, // delay between pages (ms)
            stagger: 300 // delay between loading rows (ms)
        };

        $(document).ready(function() {
            sf.board.init(sf.options);
            sf.items.init(sf.options);
            sf.items.load(sf.options);

            // Update the current time every second
            function updateTime() {
                const now = new Date();
                let hours = now.getHours();
                const minutes = String(now.getMinutes()).padStart(2, '0');

                // Determine AM or PM
                const ampm = hours >= 12 ? 'PM' : 'AM';

                // Convert hours to 12-hour format
                hours = hours % 12;
                hours = hours ? hours : 12; // the hour '0' should be '12'

                const timeString = `${hours}:${minutes} ${ampm}`;
                $('#current-time').text(timeString);
            }

            setInterval(updateTime, 1000);
            updateTime(); // Initial call to display time immediately

            // Load stations.csv and populate the dropdown, then set/get current station
            function parseCSV(text) {
                const lines = text.split(/\r?\n/).filter(Boolean);
                if (lines.length === 0) return [];
                const header = lines.shift();
                const rows = [];
                lines.forEach(line => {
                    // Try to extract stop_id and name robustly, handling quoted names
                    let stop_id = '';
                    let name = '';
                    // If name is quoted and may contain commas
                    const quotedMatch = line.match(/^([^,]+),"([^"]+)"(,|$)/);
                    if (quotedMatch) {
                        stop_id = quotedMatch[1];
                        name = quotedMatch[2];
                    } else {
                        // fallback: split by comma and take second column as name
                        const parts = line.split(',');
                        stop_id = parts[0] || '';
                        name = parts[1] || '';
                    }
                    rows.push({ stop_id: stop_id.trim(), name: name.trim() });
                });
                return rows;
            }

            $.get('/stations.csv', function(csvText) {
                const stations = parseCSV(csvText);
                const stationsArr = stations.filter(s => s && s.stop_id).map(s => ({ id: s.stop_id, name: s.name }));
                const $input = $('#station-search');
                const $results = $('#station-results');

                function renderResults(list) {
                    if (!list || list.length === 0) {
                        $results.hide();
                        return;
                    }
                    $results.empty();
                    list.forEach(item => {
                        const $row = $('<div>').addClass('station-result').attr('data-id', item.id).text(item.name + ' (' + item.id + ')').css({ padding: '6px 8px', cursor: 'pointer', borderBottom: '1px solid #222' });
                        $results.append($row);
                    });
                    $results.show();
                }

                function setStationById(id) {
                    const match = stationsArr.find(s => s.id === id);
                    const display = match ? (match.name + ' (' + match.id + ')') : id;
                    // call server to set station and wait for server to refresh data
                    $.get('/api/station', { station: id }, function() {
                        $input.val(display);
                        $('#station-title').text(display);
                        $results.hide();
                        // reload arrivals immediately
                        try { if (window.sf && sf.items && sf.options) { sf.items.load(sf.options); } } catch (e) { console.warn('Could not reload arrivals', e); }
                    }).fail(function() {
                        // still update UI locally
                        $input.val(display);
                        $('#station-title').text(display);
                        $results.hide();
                        try { if (window.sf && sf.items && sf.options) { sf.items.load(sf.options); } } catch (e) { console.warn('Could not reload arrivals', e); }
                    });
                }

                // Initialize input with server station if present
                $.get('/api/station', function(resp) {
                    const current = resp && resp.station ? resp.station : null;
                    if (current) {
                        const m = stationsArr.find(s => s.id === current);
                        const txt = m ? (m.name + ' (' + m.id + ')') : current;
                        $input.val(txt);
                        $('#station-title').text(txt);
                    } else if (stationsArr.length > 0) {
                        // set server to first station if none set
                        setStationById(stationsArr[0].id);
                    }
                }).fail(function(){
                    if (stationsArr.length > 0) {
                        const txt = stationsArr[0].name + ' (' + stationsArr[0].id + ')';
                        $input.val(txt);
                        $('#station-title').text(txt);
                    }
                });

                // input handler
                $input.on('input', function() {
                    const q = $(this).val().trim().toLowerCase();
                    if (!q) {
                        renderResults(stationsArr.slice(0, 50));
                        return;
                    }
                    const matches = stationsArr.filter(s => (s.name && s.name.toLowerCase().indexOf(q) !== -1) || (s.id && s.id.toLowerCase().indexOf(q) !== -1));
                    renderResults(matches.slice(0, 100));
                });

                // click handler for results
                $results.on('click', '.station-result', function(e) {
                    const id = $(this).attr('data-id');
                    setStationById(id);
                });

                // show suggestions on focus
                $input.on('focus', function() {
                    if ($input.val().trim() === '') {
                        renderResults(stationsArr.slice(0, 50));
                    } else {
                        $input.trigger('input');
                    }
                });

                // hide suggestions when clicking outside
                $(document).on('click', function(e) {
                    if (!$(e.target).closest('#station-search, #station-results').length) {
                        $results.hide();
                    }
                });

                // keyboard support: Enter to pick first result
                $input.on('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const first = $results.find('.station-result').first();
                        if (first.length) {
                            const id = first.attr('data-id');
                            setStationById(id);
                        }
                    }
                });

            }).fail(function() {
                // fallback: try to read arrivals for title
                $.get('/api/arrivals', function(response) {
                    if (response.data && response.data.length > 0) {
                        const currentStop = response.data[0].stop;
                        $('#station-title').text(currentStop);
                    } else {
                        $('#station-title').text('No Stop Information Available');
                    }
                });
            });
        });
    </script>
</body>
</html>
